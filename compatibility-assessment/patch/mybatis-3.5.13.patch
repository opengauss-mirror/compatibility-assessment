diff -Naur a/pom.xml b/pom.xml
--- a/pom.xml	2023-07-21 14:59:18.385889393 +0800
+++ b/pom.xml	2024-02-28 15:21:11.607241150 +0800
@@ -26,7 +26,7 @@
     <relativePath />
   </parent>
 
-  <artifactId>mybatis</artifactId>
+  <artifactId>mybatis-sql-extract</artifactId>
   <version>3.5.13</version>
   <packaging>jar</packaging>
 
diff -Naur a/src/main/java/org/apache/ibatis/builder/BaseBuilder.java b/src/main/java/org/apache/ibatis/builder/BaseBuilder.java
--- a/src/main/java/org/apache/ibatis/builder/BaseBuilder.java	2023-07-21 14:59:18.353889065 +0800
+++ b/src/main/java/org/apache/ibatis/builder/BaseBuilder.java	2024-02-28 15:21:11.608241160 +0800
@@ -115,7 +115,7 @@
     try {
       return resolveAlias(alias);
     } catch (Exception e) {
-      throw new BuilderException("Error resolving class. Cause: " + e, e);
+      return null;
     }
   }
 
diff -Naur a/src/main/java/org/apache/ibatis/builder/MapperBuilderAssistant.java b/src/main/java/org/apache/ibatis/builder/MapperBuilderAssistant.java
--- a/src/main/java/org/apache/ibatis/builder/MapperBuilderAssistant.java	2023-07-21 14:59:18.353889065 +0800
+++ b/src/main/java/org/apache/ibatis/builder/MapperBuilderAssistant.java	2024-02-28 15:21:11.608241160 +0800
@@ -158,7 +158,7 @@
 
     if (extend != null) {
       if (!configuration.hasResultMap(extend)) {
-        throw new IncompleteElementException("Could not find a parent resultmap with id '" + extend + "'");
+	return null;
       }
       ResultMap resultMap = configuration.getResultMap(extend);
       List<ResultMapping> extendedResultMappings = new ArrayList<>(resultMap.getResultMappings());
@@ -320,8 +320,7 @@
         try {
           resultMaps.add(configuration.getResultMap(resultMapName.trim()));
         } catch (IllegalArgumentException e) {
-          throw new IncompleteElementException(
-              "Could not find result map '" + resultMapName + "' referenced from '" + statementId + "'", e);
+	    return resultMaps;
         }
       }
     } else if (resultType != null) {
diff -Naur a/src/main/java/org/apache/ibatis/builder/xml/XMLMapperBuilder.java b/src/main/java/org/apache/ibatis/builder/xml/XMLMapperBuilder.java
--- a/src/main/java/org/apache/ibatis/builder/xml/XMLMapperBuilder.java	2023-07-21 14:59:18.353889065 +0800
+++ b/src/main/java/org/apache/ibatis/builder/xml/XMLMapperBuilder.java	2024-02-28 15:21:11.608241160 +0800
@@ -389,8 +389,7 @@
     String javaType = context.getStringAttribute("javaType");
     String jdbcType = context.getStringAttribute("jdbcType");
     String nestedSelect = context.getStringAttribute("select");
-    String nestedResultMap = context.getStringAttribute("resultMap",
-        () -> processNestedResultMappings(context, Collections.emptyList(), resultType));
+    String nestedResultMap = null;
     String notNullColumn = context.getStringAttribute("notNullColumn");
     String columnPrefix = context.getStringAttribute("columnPrefix");
     String typeHandler = context.getStringAttribute("typeHandler");
diff -Naur a/src/main/java/org/apache/ibatis/mapping/ResultMapping.java b/src/main/java/org/apache/ibatis/mapping/ResultMapping.java
--- a/src/main/java/org/apache/ibatis/mapping/ResultMapping.java	2023-07-21 14:59:18.356889096 +0800
+++ b/src/main/java/org/apache/ibatis/mapping/ResultMapping.java	2024-02-28 15:21:11.608241160 +0800
@@ -136,8 +136,6 @@
       // lock down collections
       resultMapping.flags = Collections.unmodifiableList(resultMapping.flags);
       resultMapping.composites = Collections.unmodifiableList(resultMapping.composites);
-      resolveTypeHandler();
-      validate();
       return resultMapping;
     }
 
diff -Naur a/src/main/java/org/apache/ibatis/parsing/GenericTokenParser.java b/src/main/java/org/apache/ibatis/parsing/GenericTokenParser.java
--- a/src/main/java/org/apache/ibatis/parsing/GenericTokenParser.java	2023-07-21 14:59:18.356889096 +0800
+++ b/src/main/java/org/apache/ibatis/parsing/GenericTokenParser.java	2024-02-28 15:21:11.608241160 +0800
@@ -15,6 +15,12 @@
  */
 package org.apache.ibatis.parsing;
 
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.regex.Pattern;
+
 /**
  * @author Clinton Begin
  */
@@ -23,6 +29,16 @@
   private final String openToken;
   private final String closeToken;
   private final TokenHandler handler;
+  private final Set<String> keywordSet = new HashSet<>(Arrays.asList(
+            "SELECT", "INSERT", "UPDATE", "DELETE", "CREATE", "ALTER",
+            "DROP", "TRUNCATE", "WHERE", "ORDER", "GROUP", "HAVING", "JOIN",
+            "LEFT", "RIGHT", "INNER", "UNION", "DISTINCT", "LIMIT", "OFFSET",
+	    "TABLE", "INDEX", "COLUMN"
+    ));
+  private static final String TAIL_REG_IN = "\\s+IN$";
+  private static final String TAIL_REG_JOIN = "\\s+JOIN$";
+  private static final Pattern PATTERN_TAIL_IN = Pattern.compile(TAIL_REG_IN, Pattern.CASE_INSENSITIVE);
+  private static final Pattern PATTERN_TAIL_JOIN = Pattern.compile(TAIL_REG_JOIN, Pattern.CASE_INSENSITIVE);
 
   public GenericTokenParser(String openToken, String closeToken, TokenHandler handler) {
     this.openToken = openToken;
@@ -30,6 +46,13 @@
     this.handler = handler;
   }
 
+  private String handleExpression(StringBuilder expression) {
+    if (keywordSet.contains(expression.toString().trim().toUpperCase())) {
+        return expression.toString().trim() + "_val";
+    }
+    return expression.toString().trim();
+  }
+
   public String parse(String text) {
     if (text == null || text.isEmpty()) {
       return "";
@@ -40,6 +63,7 @@
       return text;
     }
     char[] src = text.toCharArray();
+    int order = 1;
     int offset = 0;
     final StringBuilder builder = new StringBuilder();
     StringBuilder expression = null;
@@ -73,7 +97,22 @@
           builder.append(src, start, src.length - start);
           offset = src.length;
         } else {
-          builder.append(handler.handleToken(expression.toString()));
+          handler.handleToken(expression.toString());
+	  String sqlFrag = builder.toString().trim().toLowerCase();
+	  if ("#{".equals(this.openToken)) {
+            if (PATTERN_TAIL_IN.matcher(sqlFrag).find() && !PATTERN_TAIL_JOIN.matcher(sqlFrag).find()) {
+	        builder.append("('$" + order + "')");
+	    } else {
+		builder.append("'$" + order + "'");
+	    }
+            order++;
+          } else {
+	    if (PATTERN_TAIL_IN.matcher(sqlFrag).find() && !PATTERN_TAIL_JOIN.matcher(sqlFrag).find()) {
+		builder.append("(" + handleExpression(expression) + ")");
+	    } else {
+                builder.append(handleExpression(expression));
+	    }
+          }
           offset = end + closeToken.length();
         }
       }
diff -Naur a/src/main/java/org/apache/ibatis/scripting/xmltags/DynamicContext.java b/src/main/java/org/apache/ibatis/scripting/xmltags/DynamicContext.java
--- a/src/main/java/org/apache/ibatis/scripting/xmltags/DynamicContext.java	2023-07-21 14:59:18.357889106 +0800
+++ b/src/main/java/org/apache/ibatis/scripting/xmltags/DynamicContext.java	2024-02-28 15:21:11.608241160 +0800
@@ -70,6 +70,8 @@
     return sqlBuilder.toString().trim();
   }
 
+  public String getInnerSql() {return  getSql();}
+
   public int getUniqueNumber() {
     return uniqueNumber++;
   }
diff -Naur a/src/main/java/org/apache/ibatis/scripting/xmltags/ForEachSqlNode.java b/src/main/java/org/apache/ibatis/scripting/xmltags/ForEachSqlNode.java
--- a/src/main/java/org/apache/ibatis/scripting/xmltags/ForEachSqlNode.java	2023-07-21 14:59:18.357889106 +0800
+++ b/src/main/java/org/apache/ibatis/scripting/xmltags/ForEachSqlNode.java	2024-02-28 15:21:11.608241160 +0800
@@ -15,8 +15,11 @@
  */
 package org.apache.ibatis.scripting.xmltags;
 
+import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.Map;
-import java.util.Optional;
+
+import java.util.regex.Pattern;
 
 import org.apache.ibatis.parsing.GenericTokenParser;
 import org.apache.ibatis.session.Configuration;
@@ -31,12 +34,17 @@
   private final String collectionExpression;
   private final Boolean nullable;
   private final SqlNode contents;
-  private final String open;
-  private final String close;
   private final String separator;
   private final String item;
   private final String index;
   private final Configuration configuration;
+  private final String open;
+  private final String close;
+
+  private static final String TAIL_REG_IN = "\\s+IN$";
+  private static final String TAIL_REG_JOIN = "\\s+JOIN$";
+  private static final Pattern PATTERN_TAIL_IN = Pattern.compile(TAIL_REG_IN, Pattern.CASE_INSENSITIVE);
+  private static final Pattern PATTERN_TAIL_JOIN = Pattern.compile(TAIL_REG_JOIN, Pattern.CASE_INSENSITIVE);
 
   /**
    * @deprecated Since 3.5.9, use the
@@ -44,7 +52,7 @@
    */
   @Deprecated
   public ForEachSqlNode(Configuration configuration, SqlNode contents, String collectionExpression, String index,
-      String item, String open, String close, String separator) {
+                        String item, String open, String close, String separator) {
     this(configuration, contents, collectionExpression, null, index, item, open, close, separator);
   }
 
@@ -52,7 +60,7 @@
    * @since 3.5.9
    */
   public ForEachSqlNode(Configuration configuration, SqlNode contents, String collectionExpression, Boolean nullable,
-      String index, String item, String open, String close, String separator) {
+                        String index, String item, String open, String close, String separator) {
     this.evaluator = new ExpressionEvaluator();
     this.collectionExpression = collectionExpression;
     this.nullable = nullable;
@@ -67,16 +75,23 @@
 
   @Override
   public boolean apply(DynamicContext context) {
+    if (this.open != null && !StaticTextSqlNode.isConcateSql(context, this.open)) {
+      return false;
+    }
     Map<String, Object> bindings = context.getBindings();
-    final Iterable<?> iterable = evaluator.evaluateIterable(collectionExpression, bindings,
-        Optional.ofNullable(nullable).orElseGet(configuration::isNullableOnForEach));
-    if (iterable == null || !iterable.iterator().hasNext()) {
+    ArrayList<Object> al = new ArrayList<Object>();
+    al.add(new Object());
+    if (!al.iterator().hasNext()) {
       return true;
     }
     boolean first = true;
-    applyOpen(context);
+    boolean concatOpenClose = (this.open != null && StaticTextSqlNode.isConcateSql(context, this.open));
+    if (concatOpenClose) {
+      applyOpen(context);
+    }
     int i = 0;
-    for (Object o : iterable) {
+    for (Iterator it = al.iterator(); it.hasNext(); ++i) {
+      Object o = it.next();
       DynamicContext oldContext = context;
       if (first || separator == null) {
         context = new PrefixedContext(context, "");
@@ -101,7 +116,9 @@
       context = oldContext;
       i++;
     }
-    applyClose(context);
+    if (concatOpenClose) {
+      applyClose(context);
+    }
     context.getBindings().remove(item);
     context.getBindings().remove(index);
     return true;
@@ -137,14 +154,14 @@
     return ITEM_PREFIX + item + "_" + i;
   }
 
-  private static class FilteredDynamicContext extends DynamicContext {
+  static class FilteredDynamicContext extends DynamicContext {
     private final DynamicContext delegate;
     private final int index;
     private final String itemIndex;
     private final String item;
 
     public FilteredDynamicContext(Configuration configuration, DynamicContext delegate, String itemIndex, String item,
-        int i) {
+                                  int i) {
       super(configuration, null);
       this.delegate = delegate;
       this.index = i;
@@ -168,6 +185,11 @@
     }
 
     @Override
+    public String getInnerSql() {
+      return delegate.getInnerSql();
+    }
+
+    @Override
     public void appendSql(String sql) {
       GenericTokenParser parser = new GenericTokenParser("#{", "}", content -> {
         String newContent = content.replaceFirst("^\\s*" + item + "(?![^.,:\\s])", itemizeItem(item, index));
@@ -228,9 +250,15 @@
     }
 
     @Override
+    public String getInnerSql() {
+      return delegate.getInnerSql();
+    }
+
+    @Override
     public int getUniqueNumber() {
       return delegate.getUniqueNumber();
     }
   }
 
 }
+
diff -Naur a/src/main/java/org/apache/ibatis/scripting/xmltags/IfSqlNode.java b/src/main/java/org/apache/ibatis/scripting/xmltags/IfSqlNode.java
--- a/src/main/java/org/apache/ibatis/scripting/xmltags/IfSqlNode.java	2023-07-21 14:59:18.357889106 +0800
+++ b/src/main/java/org/apache/ibatis/scripting/xmltags/IfSqlNode.java	2024-02-28 15:21:11.609241170 +0800
@@ -31,11 +31,8 @@
 
   @Override
   public boolean apply(DynamicContext context) {
-    if (evaluator.evaluateBoolean(test, context.getBindings())) {
-      contents.apply(context);
-      return true;
-    }
-    return false;
+    contents.apply(context);
+    return true;
   }
 
 }
diff -Naur a/src/main/java/org/apache/ibatis/scripting/xmltags/StaticTextSqlNode.java b/src/main/java/org/apache/ibatis/scripting/xmltags/StaticTextSqlNode.java
--- a/src/main/java/org/apache/ibatis/scripting/xmltags/StaticTextSqlNode.java	2023-07-21 14:59:18.357889106 +0800
+++ b/src/main/java/org/apache/ibatis/scripting/xmltags/StaticTextSqlNode.java	2024-03-02 10:56:55.789085219 +0800
@@ -15,11 +15,61 @@
  */
 package org.apache.ibatis.scripting.xmltags;
 
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.StringJoiner;
+import java.util.regex.Pattern;
+
 /**
  * @author Clinton Begin
  */
 public class StaticTextSqlNode implements SqlNode {
-  private final String text;
+  private static final List<String> concateList = Arrays.asList("AND", "OR", "IN", "NOT\\s+IN", "ON", "LIKE", "LIMIT", "BETWEEN",
+          "ORDER\\s+BY", "GROUP\\s+BY", "HAVING", "JOIN", "LEFT\\s+JOIN", "RIGHT\\s+JOIN", "INNER\\s+JOIN", "WHERE",
+          "VALUES", ",", "SELECT", "INSERT", "UPDATE", "DROP", "DELETE", "FROM", "SET", "INTO", "WHEN", "CASE", "END",
+          "DISTINCT", "=", ">=", "<=", ">", "<", "ASC", "DESC");
+  private static final StringJoiner sqlBuilder = new StringJoiner(" ");
+
+  private static final String SET_REG = "^update\\s+\\S+\\s+set";
+  private static final String ORDERBY_TAIL_REG = "order\\s+by\\s+\\S+(\\s+\\S+)?$";
+  private static final String ORDERBY_HEAD_REG = "^order\\s+by";
+  private static final String ORDERBY_FRAGMENT_REG = "^order\\s+by\\s+\\S+\\s+\\S+?$";
+  private static final String LIMIT_FRAGMENT_REG = "limit\\s+(\\S+|\\S+\\s+,\\s+\\S+)$";
+  private static final String ON_FRAGMENT_REG = "^on\\s+";
+  private static final String HEAD_REG;
+  private static final String TAIL_REG;
+  private static final Pattern PATTERN_HEAD_REG;
+  private static final Pattern PATTERN_TAIL_REG;
+  private static final Pattern PATTERN_SET_REG = Pattern.compile(SET_REG, Pattern.CASE_INSENSITIVE);
+  private static final Pattern PATTERN_ORDERBY_TAILREG = Pattern.compile(ORDERBY_TAIL_REG, Pattern.CASE_INSENSITIVE);
+  private static final Pattern PATTERN_ORDERBY_HEADREG = Pattern.compile(ORDERBY_HEAD_REG, Pattern.CASE_INSENSITIVE);
+  private static final Pattern PATTERN_ORDERBY_FRAGMENTREG = Pattern.compile(ORDERBY_FRAGMENT_REG, Pattern.CASE_INSENSITIVE);
+  private static final Pattern PATTERN_LIMIT_FRAGMENTREG = Pattern.compile(LIMIT_FRAGMENT_REG, Pattern.CASE_INSENSITIVE);
+  private static final Pattern PATTERN_ON_FRAGMENTREG = Pattern.compile(ON_FRAGMENT_REG, Pattern.CASE_INSENSITIVE);
+
+  static {
+    StringBuilder headbuilder = new StringBuilder();
+    StringBuilder tailbuilder = new StringBuilder();
+    Iterator var2 = concateList.iterator();
+
+    while(var2.hasNext()) {
+      String keyword = (String)var2.next();
+      if (!",".equals(keyword)) {
+        headbuilder.append("|^" + keyword + "\\s+|^" + keyword + "$");
+        tailbuilder.append("|\\s+" + keyword + "$|^" + keyword + "$");
+      }
+    }
+
+    HEAD_REG = headbuilder.toString().substring(1);
+    TAIL_REG = tailbuilder.toString().substring(1);
+    PATTERN_HEAD_REG = Pattern.compile(HEAD_REG, Pattern.CASE_INSENSITIVE);
+    PATTERN_TAIL_REG = Pattern.compile(TAIL_REG, Pattern.CASE_INSENSITIVE);
+  }
+
+
+
+  private String text;
 
   public StaticTextSqlNode(String text) {
     this.text = text;
@@ -27,8 +77,103 @@
 
   @Override
   public boolean apply(DynamicContext context) {
-    context.appendSql(text);
-    return true;
+    dealOrderByFragment();
+    if (StrategyChoice.getStrategy() == StrategyChoice.STATEGY_CONCAT_DIRECT) {
+      context.appendSql(text);
+      return true;
+    } else if(StrategyChoice.getStrategy() == StrategyChoice.STATEGY_JUDGE_KEYWORD) {
+      if (isConcateSql(context, text)) {
+        context.appendSql(text);
+        return true;
+      }
+    }
+    return false;
+  }
+
+  public static boolean isConcateSql(DynamicContext context, String staticText) {
+    String sql_fragment = context.getInnerSql().toUpperCase();
+    if (sql_fragment.length() == 0) {
+      return true;
+    } else {
+      boolean startWithKeyword = PATTERN_HEAD_REG.matcher(staticText.trim()).find() || staticText.trim().startsWith(",");
+      boolean endWithKeyword = PATTERN_TAIL_REG.matcher(sql_fragment).find() || sql_fragment.endsWith(",");
+      if (startWithKeyword == endWithKeyword) {
+        return handleTheSame(startWithKeyword, endWithKeyword, sql_fragment, staticText);
+      } else {
+        return handleMultiKey(context, staticText);
+      }
+    }
+  }
+
+    private static boolean handleTheSame(boolean startWithKeyword, boolean endWithKeyword, String sql_fragment, String staticText) {
+      if (!startWithKeyword && !endWithKeyword) {
+        if (sql_fragment.endsWith("(") || staticText.trim().startsWith(")")) {
+          return true;
+        }
+      }
+
+    String text_upper = staticText.toUpperCase().trim();
+    if (startWithKeyword && endWithKeyword) {
+      if (sql_fragment.endsWith("INSERT") && text_upper.startsWith("INTO")) {
+        return true;
+      }
+
+      if (sql_fragment.endsWith("DELETE") && text_upper.startsWith("FROM")) {
+        return true;
+      }
+
+      if (sql_fragment.endsWith("SELECT") && text_upper.startsWith("DISTINCT")) {
+        return true;
+      }
+
+      if (sql_fragment.endsWith("END") && text_upper.startsWith("WHERE")) {
+        return true;
+      }
+    }
+
+    return false;
+  }
+
+  private static boolean handleMultiKey(DynamicContext context, String staticText) {
+    String sql_fragment = context.getInnerSql().toUpperCase();
+    String text_upper = staticText.toUpperCase().trim();
+    if (PATTERN_ORDERBY_TAILREG.matcher(sql_fragment).find() && PATTERN_ORDERBY_HEADREG.matcher(text_upper).find()) {
+      return false;
+    }
+    if (PATTERN_LIMIT_FRAGMENTREG.matcher(sql_fragment).find() && PATTERN_ORDERBY_HEADREG.matcher(text_upper).find()) {
+      return false;
+    }
+    // handle join .... on
+    if ((countSubString(sql_fragment.replaceAll("\\s+", " "), " ON ")
+            == countSubString(sql_fragment.replaceAll("\\s+", " "), " JOIN "))
+            && PATTERN_ON_FRAGMENTREG.matcher(text_upper).find()) {
+      return false;
+    } else {
+      return !PATTERN_SET_REG.matcher(sql_fragment).find() || !text_upper.startsWith("SET ");
+    }
+  }
+
+  private void dealOrderByFragment() {
+    if (PATTERN_ORDERBY_FRAGMENTREG.matcher(this.text.trim()).find()) {
+      String[] sqlArr = this.text.trim().split("\\s+");
+      if (!(sqlArr[3].toUpperCase().startsWith("DESC") || (sqlArr[3].toUpperCase().startsWith("ASC")))
+              && !sqlArr[2].endsWith(",") && !concateList.contains(sqlArr[3].toUpperCase()) && !sqlArr[3].startsWith(",")) {
+	this.text = sqlArr[0] + " " + sqlArr[1] + " " + sqlArr[2] + " ASC";
+      }
+    }
+  }
+
+  private static int countSubString(String str, String subStr) {
+    int cont = 0;
+    int index = 0;
+    while ((index = str.indexOf(subStr, index)) != -1) {
+      cont++;
+      index += subStr.length();
+    }
+    return cont;
   }
 
 }
+
+
+
diff -Naur a/src/main/java/org/apache/ibatis/scripting/xmltags/StrategyChoice.java b/src/main/java/org/apache/ibatis/scripting/xmltags/StrategyChoice.java
--- a/src/main/java/org/apache/ibatis/scripting/xmltags/StrategyChoice.java	1970-01-01 08:00:00.000000000 +0800
+++ b/src/main/java/org/apache/ibatis/scripting/xmltags/StrategyChoice.java	2024-02-28 15:21:11.609241170 +0800
@@ -0,0 +1,31 @@
+/*
+ *    Copyright 2009-2023 the original author or authors.
+ *
+ *    Licensed under the Apache License, Version 2.0 (the "License");
+ *    you may not use this file except in compliance with the License.
+ *    You may obtain a copy of the License at
+ *
+ *       https://www.apache.org/licenses/LICENSE-2.0
+ *
+ *    Unless required by applicable law or agreed to in writing, software
+ *    distributed under the License is distributed on an "AS IS" BASIS,
+ *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ *    See the License for the specific language governing permissions and
+ *    limitations under the License.
+ */
+package org.apache.ibatis.scripting.xmltags;
+
+
+public class StrategyChoice {
+    public static final Integer STATEGY_JUDGE_KEYWORD = 1;
+    public static final Integer STATEGY_CONCAT_DIRECT = 0;
+    private static Integer strategyChoice = STATEGY_CONCAT_DIRECT;
+
+    public static Integer getStrategy() {
+        return strategyChoice;
+    }
+
+    public static void setStrategy(Integer strate) {
+        strategyChoice = strate;
+    }
+}
diff -Naur a/src/main/java/org/apache/ibatis/scripting/xmltags/TrimSqlNode.java b/src/main/java/org/apache/ibatis/scripting/xmltags/TrimSqlNode.java
--- a/src/main/java/org/apache/ibatis/scripting/xmltags/TrimSqlNode.java	2023-07-21 14:59:18.357889106 +0800
+++ b/src/main/java/org/apache/ibatis/scripting/xmltags/TrimSqlNode.java	2024-02-28 15:21:11.609241170 +0800
@@ -72,7 +72,7 @@
     return Collections.emptyList();
   }
 
-  private class FilteredDynamicContext extends DynamicContext {
+  class FilteredDynamicContext extends DynamicContext {
     private final DynamicContext delegate;
     private boolean prefixApplied;
     private boolean suffixApplied;
@@ -121,6 +121,10 @@
       return delegate.getSql();
     }
 
+    public String getInnerSql() {
+      return this.sqlBuffer.toString().trim();
+    }
+
     private void applyPrefix(StringBuilder sql, String trimmedUppercaseSql) {
       if (!prefixApplied) {
         prefixApplied = true;
diff -Naur a/src/main/java/org/apache/ibatis/scripting/xmltags/VarDeclSqlNode.java b/src/main/java/org/apache/ibatis/scripting/xmltags/VarDeclSqlNode.java
--- a/src/main/java/org/apache/ibatis/scripting/xmltags/VarDeclSqlNode.java	2023-07-21 14:59:18.357889106 +0800
+++ b/src/main/java/org/apache/ibatis/scripting/xmltags/VarDeclSqlNode.java	2024-02-28 15:21:11.609241170 +0800
@@ -30,8 +30,7 @@
 
   @Override
   public boolean apply(DynamicContext context) {
-    final Object value = OgnlCache.getValue(expression, context.getBindings());
-    context.bind(name, value);
+    context.bind(name, null);
     return true;
   }
 
